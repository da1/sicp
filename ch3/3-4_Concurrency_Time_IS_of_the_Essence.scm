;; 3.4 並列性：時が本質的
;; 状態，同一性および変化の論点の中心は，計算モデルに時間を含めたところである．

;; システムを並列的に動く計算プロセスの集まりとしてモデル化する

;; 3.4.1 並列システムでの時
;; 一般的現象は，複数のプロセスが共通の状態変数を共有することがあるということ．

;; 並列プログラムの正しい振る舞い
;; 並列プログラムに紛れ込む微妙な虫の代表
;; 並列に対する可能な制限の一つは，共有状態変数を変更する２つの演算は，
;; 同時に起きてはいけないと限定する．ただし，これは非常に難しい
;; もう少し厳しくない制限
;; プロセスがある順序で逐次的に走ったのと，同じ結果を生じるように保証すること

;; 3.4.2 並列性の制御機構
;; 並列プロセスの混ざり合いを制約する一般的な機構の一つ，直列変換器（serializer）

;; 共有状態へのアクセスの直列化
;; プロセスは並列にじっこうできるが，並列には実行できない手続きの集まりがある．
;; 共有変数へのアクセス制御に直列化を使う．共有変数を，その変数の前の値に基づいて更新しようと思えば，
;; その変数の前の値へのアクセスと，その変数への新しい値の代入とを同一の手続きの中に置く．そうすればその変数に代入する他の手続きは，
;; これらの手続きを同一の直列変換器で直列化することで，この手続きと他の手続きは並列には走れないことが保証できる．

;; Schemeの直列変換器

;; parallel-executeという手続きを取り入れたとする
;; (parallel-execute <p1> <p2> .. <pk>)

;; (define x 10)
;; (define s (make-serializer))
;; (parallel-execute (s (lambda () (set! x (* x x))))
;;                   (s (lambda () (set! x (+ x 1)))))

;; 直列変換器の実装
;; 直列変換器はmutexで実装する
(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args) ;;.は可変長引数
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))

(define (make-mutex)
  (let ((cell (list #f)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
               (the-mutex 'aquire)))
            ((eq? m 'release) (clear! cell))))
    the-mutex))

(define (clear! cell)
  (set-car! cell false))

(define (test-and-set! cell)
  (if (car cell)
    #t
    (begin (set-car! cell true)
           #f)))
;; test-and-set!はアトミックでないといけない


;; 並列性，時および通信
;; メモリの内容がすべての時点で一貫した状態にあるとは限らない
;; 最近の並列変換器パラダイムは，並列制御の新しい解決法に変わられつつある

;; バリア同期など

;;共有状態の問題点は，巨大分散システムにもある
;;残高が変わったと言えるのは，口座残高が変わった直後，同期されたあと．
;;別の支店からアクセスしたときに，正しい振る舞いになるための制約とはなにか
;;関係するのは，PeterとPaulが個別に見た振る舞いと，同期直後の口座の状態である

;; 並列制御における時の概念は，通信と結びついている
;; 計算モデルで時と状態の扱いで出会った複雑性は，実は物理的宇宙の基本的複雑性を反映している


